{"version":3,"sources":["..\\..\\..\\..\\assets\\Script/assets\\Script\\Algorithm.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"..\\..\\..\\..\\assets\\Script","sourcesContent":["\r\nconst {ccclass, property} = cc._decorator;\r\n\r\n@ccclass\r\nexport class Algorithm extends cc.Component {\r\n    public static routes: cc.Vec2[] = [];//路径记录\r\n    /**\r\n     * @description: 判断两个坐标上的图形是否可消除\r\n     * @param {type} 坐标，坐标，二维数组\r\n     * @return: true/false\r\n     */\r\n    public static canBeRemoved(firstPos: cc.Vec2, secondPos: cc.Vec2, mapArray: number[][]): boolean{\r\n        if(this.isSamePoint(firstPos, secondPos)){\r\n            return false;\r\n        }\r\n        if(mapArray[firstPos.x][firstPos.y] !== mapArray[secondPos.x][secondPos.y]){\r\n            return false;\r\n        }\r\n        if(this.isHorizon(firstPos, secondPos, mapArray)){\r\n            return true;\r\n        }\r\n        if(this.isVertical(firstPos, secondPos, mapArray)){\r\n            return true;\r\n        }\r\n        if(this.isTurnOnce(firstPos, secondPos, mapArray)){\r\n            return true;\r\n        }\r\n        if(this.isTurnTwice(firstPos, secondPos, mapArray)){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * @description: 判断两点在水平方向上是否无障碍物(是否在同一条水平线上，且两点之间没有障碍物)\r\n     * @param {type} 坐标，坐标，二维数组\r\n     * @return: true/false\r\n     */\r\n    private static isHorizon(firstPos: cc.Vec2, secondPos: cc.Vec2, mapArray: number[][]): boolean{\r\n        if(firstPos.y !== secondPos.y){\r\n            return false;\r\n        }\r\n        const startX = Math.min(firstPos.x, secondPos.x), endX = Math.max(firstPos.x, secondPos.x);             \r\n        for(let x=startX+1; x<endX; ++x){\r\n            if(this.isBlocked(cc.v2(x, firstPos.y), mapArray)){\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * @description: 判断两点在垂直方向上是否无障碍物\r\n     * @param {type} 坐标1，坐标2，二维数组\r\n     * @return: true/false\r\n     */\r\n    private static isVertical(firstPos: cc.Vec2, secondPos: cc.Vec2,  mapArray: number[][]): boolean{\r\n        if(firstPos.x !== secondPos.x){\r\n            return false;\r\n        }\r\n        let startY = Math.min(firstPos.y, secondPos.y), endY = Math.max(firstPos.y, secondPos.y);       \r\n        for(let y=startY+1; y<endY; ++y){\r\n            if(this.isBlocked(cc.v2(firstPos.x, y), mapArray)){\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * @description: 判断两点能否通过一个拐点相连\r\n     * @param {type} 坐标，坐标，二维数组\r\n     * @return: true/false\r\n     */\r\n    private static isTurnOnce(firstPos: cc.Vec2, secondPos: cc.Vec2, mapArray: number[][]): boolean{\r\n        let tempPosA: cc.Vec2 = cc.v2(firstPos.x, secondPos.y), tempPosB: cc.Vec2 = cc.v2(secondPos.x, firstPos.y), temp: boolean = false;\r\n        if(!this.isBlocked(tempPosA, mapArray)){\r\n            temp = this.isHorizon(tempPosA, secondPos, mapArray) && this.isVertical(tempPosA, firstPos, mapArray) || this.isVertical(tempPosA, secondPos, mapArray) && this.isHorizon(tempPosA, firstPos, mapArray);                   \r\n            if(temp){return true}//该对角可作为拐点时不必判断另一个对角点了\r\n        }\r\n        if(!this.isBlocked(tempPosB, mapArray)){\r\n            temp = this.isHorizon(tempPosB, secondPos, mapArray) && this.isVertical(tempPosB, firstPos, mapArray) || this.isVertical(tempPosB, secondPos, mapArray) && this.isHorizon(tempPosB, firstPos, mapArray);                    \r\n            if(temp){return true}\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * @description: 判断两点能否通过两个拐点相连\r\n     * @param {type} 坐标，坐标，二维数组\r\n     * @return: true/false\r\n     */\r\n    private static isTurnTwice(firstPos: cc.Vec2, secondPos: cc.Vec2, mapArray: number[][]): boolean{\r\n        //两个点在同一行,遍历某点垂直方向，找到一点c与该点垂直可消，与另一点一个拐点可消\r\n        let c: cc.Vec2;\r\n        if(firstPos.y === secondPos.y){\r\n            for(let y=mapArray[0].length-1; y>=0; --y){\r\n                c = cc.v2(firstPos.x, y);\r\n                if(this.isBlocked(c, mapArray)){\r\n                    continue;\r\n                }\r\n                if(this.isVertical(c, firstPos, mapArray) && this.isTurnOnce(c, secondPos, mapArray)){\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        //两个点在同一列，遍历某点水平方向，找到点c与该点水平可消，与另一点一个拐点可消\r\n        if(firstPos.x === secondPos.x){\r\n            for(let col=0; col<mapArray.length; ++col){\r\n                c = cc.v2(col, firstPos.y);\r\n                if(this.isBlocked(c, mapArray)){\r\n                    continue;\r\n                }\r\n                if(this.isHorizon(c, firstPos, mapArray) && this.isTurnOnce(c, secondPos, mapArray)){\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        //两点在不同列不同行\r\n        //①遍历第一点水平线 找到点c与第一点水平可消，与第二点一个拐点可消\r\n        for(let x=mapArray.length-1; x>=0; --x){       \r\n            c = cc.v2(x, firstPos.y);\r\n            if(this.isBlocked(c, mapArray)){\r\n                continue;\r\n            }\r\n            if(this.isHorizon(c, firstPos, mapArray) && this.isTurnOnce(c, secondPos, mapArray)){\r\n                return true;\r\n            }\r\n        }\r\n        //②遍历第一点垂直线 找到点c与第一点垂直可消，与第二点一个拐点可消\r\n        for(let y=mapArray[0].length-1; y>=0; --y){\r\n            c = cc.v2(firstPos.x, y);\r\n            if(this.isBlocked(c, mapArray)){\r\n                continue;\r\n            }\r\n            if(this.isVertical(c, firstPos, mapArray) && this.isTurnOnce(c, secondPos, mapArray)){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * @description: 判断某个位置上是否有障碍物\r\n     * @param {type} 坐标，二维数组\r\n     * @return: true/false\r\n     */\r\n    private static isBlocked(pos: cc.Vec2, mapArray: number[][]): boolean{\r\n        return mapArray[pos.x][pos.y] > 0;\r\n    }\r\n    //判断两个点是否重合\r\n    /**\r\n     * @description: 判断两点是否重合\r\n     * @param {type} 坐标，坐标\r\n     * @return: true/false\r\n     */\r\n    private static isSamePoint (firstPos: cc.Vec2, secondPos: cc.Vec2): boolean{\r\n        return firstPos.x === secondPos.x && firstPos.y === secondPos.y;\r\n    }\r\n    //在可消除路径上添加空节点 用以显示路径\r\n    private static createNodes () {\r\n\r\n    }\r\n    //删除在路径上添加的空节点\r\n    private static removeNodes () {\r\n\r\n    }\r\n}\r\n"]}